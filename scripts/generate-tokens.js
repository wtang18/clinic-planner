#!/usr/bin/env node

/**
 * Token Generation Script
 *
 * Reads design-tokens-variables-full.json exported from Figma and generates:
 * - CSS custom properties for primitives
 * - CSS custom properties for semantic tokens (with mode support)
 * - CSS custom properties for decorative tokens (with mode support)
 *
 * Usage: npm run tokens:generate
 */

const fs = require('fs');
const path = require('path');

// Paths
const TOKENS_JSON = path.join(__dirname, '../src/design-system/tokens/design-tokens-variables-full.json');
const OUTPUT_DIR = path.join(__dirname, '../src/styles/tokens');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Read and parse tokens JSON
console.log('üìñ Reading tokens from:', TOKENS_JSON);
const tokensData = JSON.parse(fs.readFileSync(TOKENS_JSON, 'utf8'));

// Helper: Convert Figma color object to CSS hex
function colorToHex(color) {
  const r = Math.round(color.r * 255).toString(16).padStart(2, '0');
  const g = Math.round(color.g * 255).toString(16).padStart(2, '0');
  const b = Math.round(color.b * 255).toString(16).padStart(2, '0');
  const hex = `#${r}${g}${b}`;

  if (color.a !== undefined && color.a < 1) {
    const a = Math.round(color.a * 255).toString(16).padStart(2, '0');
    return `${hex}${a}`;
  }

  return hex;
}

// Helper: Convert token name to CSS variable name
function tokenNameToCSSVar(name) {
  return name.replace(/\//g, '-');
}

// Helper: Resolve variable alias to CSS var reference
function resolveAlias(aliasId, allVariables) {
  // Find the variable by ID
  for (const collection of tokensData.collections) {
    const variable = collection.variables.find(v => v.id === aliasId);
    if (variable) {
      return `var(--${tokenNameToCSSVar(variable.name)})`;
    }
  }
  console.warn(`‚ö†Ô∏è  Warning: Could not resolve alias ${aliasId}`);
  return '/* UNRESOLVED */';
}

// Helper: Format value based on type
function formatValue(value, resolvedType, allVariables) {
  if (!value) return '/* UNDEFINED */';

  // Handle aliases
  if (value.type === 'VARIABLE_ALIAS') {
    return resolveAlias(value.id, allVariables);
  }

  // Handle direct values
  switch (resolvedType) {
    case 'COLOR':
      return colorToHex(value);
    case 'FLOAT':
      return `${value}px`;
    case 'STRING':
      return value;
    default:
      return String(value);
  }
}

// Generate CSS file header
function generateHeader(collectionName, mode = null) {
  const modeStr = mode ? ` (${mode} mode)` : '';
  return `/**
 * ${collectionName}${modeStr}
 *
 * Auto-generated from design-tokens-variables-full.json
 * DO NOT EDIT THIS FILE DIRECTLY
 *
 * To update tokens:
 * 1. Export fresh JSON from Figma
 * 2. Replace design-tokens-variables-full.json
 * 3. Run: npm run tokens:generate
 *
 * Generated: ${new Date().toISOString()}
 */

`;
}

// Process a collection and generate CSS
function generateCSSForCollection(collection) {
  const files = [];

  console.log(`\nüì¶ Processing: ${collection.name}`);
  console.log(`   Variables: ${collection.variables.length}`);
  console.log(`   Modes: ${collection.modes.map(m => m.name).join(', ')}`);

  // For each mode, generate a CSS file
  collection.modes.forEach(mode => {
    const cssVars = [];

    collection.variables.forEach(variable => {
      const value = variable.valuesByMode[mode.modeId];
      const cssVarName = `--${tokenNameToCSSVar(variable.name)}`;
      const cssValue = formatValue(value, variable.resolvedType, collection.variables);

      // Add description as comment if available
      if (variable.description) {
        cssVars.push(`  /* ${variable.description} */`);
      }

      cssVars.push(`  ${cssVarName}: ${cssValue};`);
    });

    // Determine selector based on collection type and mode
    let selector = ':root';
    let filename = collection.name.toLowerCase().replace(/[:\s]+/g, '-');

    if (collection.name.includes('Semantic: Color')) {
      if (mode.name === 'on-dark') {
        selector = '[data-theme="dark"]';
        filename = 'semantic-color-dark';
      } else {
        selector = ':root, [data-theme="light"]';
        filename = 'semantic-color-light';
      }
    } else if (collection.name.includes('Semantic: Typography')) {
      if (mode.name === 'large-viewport') {
        selector = '@media (min-width: 769px) {\n  :root';
        filename = 'semantic-typography-large';
      } else {
        selector = '@media (max-width: 768px) {\n  :root';
        filename = 'semantic-typography-small';
      }
    } else if (collection.name.includes('Decorative: Color')) {
      if (mode.name === 'on-dark') {
        selector = '[data-theme="dark"]';
        filename = 'decorative-color-dark';
      } else {
        selector = ':root, [data-theme="light"]';
        filename = 'decorative-color-light';
      }
    } else if (mode.name !== 'Value' && mode.name !== 'Mode 1') {
      filename += `-${mode.name.toLowerCase().replace(/\s+/g, '-')}`;
    }

    // Generate CSS content
    let cssContent = generateHeader(collection.name, mode.name);

    const needsMediaClose = selector.includes('@media');

    if (needsMediaClose) {
      cssContent += `${selector.split('\n')[0]}\n`;
      cssContent += `  ${selector.split('\n')[1]} {\n`;
      cssContent += cssVars.map(line => `  ${line}`).join('\n');
      cssContent += '\n  }\n}\n';
    } else {
      cssContent += `${selector} {\n`;
      cssContent += cssVars.join('\n');
      cssContent += '\n}\n';
    }

    files.push({ filename: `${filename}.css`, content: cssContent });
  });

  return files;
}

// Main generation
console.log('üöÄ Generating token CSS files...\n');

const allFiles = [];

tokensData.collections.forEach(collection => {
  const files = generateCSSForCollection(collection);
  allFiles.push(...files);
});

// Write all files
console.log('\nüìù Writing CSS files...\n');
allFiles.forEach(({ filename, content }) => {
  const filepath = path.join(OUTPUT_DIR, filename);
  fs.writeFileSync(filepath, content, 'utf8');
  console.log(`   ‚úÖ ${filename}`);
});

// Generate index.css that imports all token files
const indexContent = `/**
 * Token System Index
 *
 * Imports all token CSS files in the correct order:
 * 1. Primitives (base values)
 * 2. Semantic (contextual tokens that reference primitives)
 * 3. Decorative (edge case tokens)
 *
 * Import this file in your main CSS/app entry point.
 */

/* Primitives Layer - Base values, not for direct use in components */
@import './primitives-color-ramp.css';
@import './primitives-typography.css';
@import './primitives-dimensions.css';

/* Semantic Layer - Use these in components */
@import './semantic-color-light.css';
@import './semantic-color-dark.css';
@import './semantic-typography-small.css';
@import './semantic-typography-large.css';
@import './semantic-dimensions.css';

/* Decorative Layer - Edge cases */
@import './decorative-color-light.css';
@import './decorative-color-dark.css';
`;

fs.writeFileSync(path.join(OUTPUT_DIR, 'index.css'), indexContent, 'utf8');
console.log(`   ‚úÖ index.css`);

console.log('\n‚ú® Token generation complete!\n');
console.log('üìÅ Output directory:', OUTPUT_DIR);
console.log('\nüí° Next steps:');
console.log('   1. Review generated CSS files');
console.log('   2. Import tokens in your app: import "@/styles/tokens"');
console.log('   3. Update Tailwind config to use CSS variables');
console.log('   4. Test in Storybook\n');
